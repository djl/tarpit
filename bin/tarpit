#!/usr/bin/env python
"""
Usage: tarpit [<backup>]
"""
import datetime
import os
import subprocess
import sys
import textwrap

try:
    import configparser
except ImportError:
    import ConfigParser as configparser


FILE = '~/.tarpit'
MESSAGE_WIDTH = 72


def error(msg, exitcode=1):
    """
    Print ``msg`` to stderr and exit with ``exitcode``.
    """
    msg = os.path.basename(sys.argv[0]) + ': ' + msg
    msg = '\n'.join(textwrap.wrap(msg, MESSAGE_WIDTH)) + '\n'
    sys.stderr.write(msg)
    sys.exit(exitcode)

def expand(fn):
    """
    Fully expand a path.
    """
    fn = os.path.expandvars(fn)
    fn = os.path.expanduser(fn)
    return os.path.abspath(fn)


class Tarpit(object):

    OPTIONS = ['name', 'files', 'exclude']

    def __init__(self):
        self.setup_config()

    def backup(self, backup):
        """
        Run a backup.
        """
        try:
            options = self.options[backup]
        except KeyError:
            error("Invalid backup '%s'" % backup)

        backup = Backup(**options)
        backup.run()

    def setup_config(self):
        """
        Parse config file.
        """
        self.config = configparser.ConfigParser()
        self.backups = []
        self.options = {}

        try:
            self.config.readfp(open(expand(FILE)))
        except IOError:
            error("Couldn't read your config file.")

        for section in self.config.sections():
            self.backups.append(section)
            self.options[section] = {}
            for option in self.OPTIONS:
                if self.config.has_option(section, option):
                    self.options[section][option] = self.config.get(section, option)



class Backup(object):

    REQUIRED_OPTIONS = ['name', 'files']

    def __init__(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

        self.validate_options()
        self.validate_files()
        self.validate_exclude()

    def create_archive(self):
        """
        Create the archive from the given list of files.
        """
        filename = datetime.datetime.now().strftime(self.name)
        commands = ['tarsnap', '-c', '-f', filename]
        if self.exclude:
            commands.append('--exclude ' + ' '.join(self.exclude))
        commands.append(' '.join(self.files))
        proc = subprocess.Popen(' '.join(commands), shell=True)
        proc.communicate()

    def validate_exclude(self):
        """
        Validate the `exclude` option.
        """
        try:
            self.exclude = self.validate_filenames(self.exclude)
        except AttributeError:
            self.exclude = []

    def validate_filenames(self, files):
        """
        Make sure the given list files is not empty and that each file
        exists.
        """
        if not files:
            error("No files specified for backup '%s'" % self.backup)

        validated = []
        for fn in files.split(','):
            fn = expand(fn.strip())
            if not any([os.path.isfile(fn), os.path.isdir(fn)]):
                error("Invalid file/directory '%s' for backup '%s'" % (fn, self.backup))
            validated.append(fn)
        return validated

    def validate_files(self):
        """
        Validate the `files` option.
        """
        self.files = self.validate_filenames(self.files)

    def validate_options(self):
        """
        Make sure each required option is present.
        """
        for option in self.REQUIRED_OPTIONS:
            if not getattr(self, option, None):
                error("Backup '%s' is missing option '%s'" % (self.backup, option))

    def run(self):
        """
        Create an archive and upload it, encrypting if necessary.
        """
        try:
            self.create_archive()
        except Exception as e:
            error(e)


def main():
    # help message
    if len(sys.argv) > 1 and sys.argv[1] in ('-h', '--help'):
        sys.stderr.write(__doc__.lstrip())
        sys.exit(2)

    # the heavy lifter
    tarpit = Tarpit()

    # list all backups
    if len(sys.argv) == 1:
        sys.stdout.write('\n'.join(sorted(tarpit.backups)) + '\n')
        sys.exit(0)

    # do it
    tarpit.backup(sys.argv[1])

if __name__ == '__main__':
    main()
